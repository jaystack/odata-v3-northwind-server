{"version":3,"sources":["node_modules/browser-pack/_prelude.js","IndexedDbProvider.js","src/Types/StorageProviders/IndexedDB/IndexedDBConverter.js","src/Types/StorageProviders/IndexedDB/IndexedDBStorageProvider.js","src/Types/StorageProviders/IndexedDB/index.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","$data","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","_dereq_","_interopRequireDefault","obj","__esModule","default","_core","_core2","IndexedDBConverter","fromDb","$data.Enum","v","enumType","Container","convertTo","$data.Byte","proxyConverter","$data.SByte","$data.Decimal","$data.Float","$data.Int16","$data.Int64","$data.Integer","$data.Int32","$data.Number","$data.Date","$data.DateTimeOffset","$data.Duration","$data.Day","$data.Time","$data.String","$data.Boolean","$data.Blob","b","Blob","$data.Array","arr","undefined","Array","$data.Object","$data.Guid","parseGuid","toString","$data.GeographyPoint","GeographyPoint","$data.GeographyLineString","GeographyLineString","$data.GeographyPolygon","GeographyPolygon","$data.GeographyMultiPoint","GeographyMultiPoint","$data.GeographyMultiLineString","GeographyMultiLineString","$data.GeographyMultiPolygon","GeographyMultiPolygon","$data.GeographyCollection","GeographyCollection","$data.GeometryPoint","GeometryPoint","$data.GeometryLineString","GeometryLineString","$data.GeometryPolygon","GeometryPolygon","$data.GeometryMultiPoint","GeometryMultiPoint","$data.GeometryMultiLineString","GeometryMultiLineString","$data.GeometryMultiPolygon","GeometryMultiPolygon","$data.GeometryCollection","GeometryCollection","toDb","JSON","parse","stringify","jaydata/core","2","_typeof","Symbol","iterator","constructor","Class","StorageProviderBase","cfg","ctxInstance","indexedDB","__global","webkitIndexedDB","mozIndexedDB","msIndexedDB","IDBRequest","webkitIDBRequest","mozIDBRequest","msIDBRequest","IDBTransaction","webkitIDBTransaction","mozIDBTransaction","msIDBTransaction","IDBTransactionType","READ_ONLY","READ_WRITE","VERSIONCHANGE","IDBKeyRange","webkitIDBKeyRange","mozIDBKeyRange","msIDBKeyRange","IDBDatabaseException","webkitIDBDatabaseException","mozIDBDatabaseException","msIDBDatabaseException","IDBOpenDBRequest","webkitIDBOpenDBRequest","mozIDBOpenDBRequest","msIDBOpenDBRequest","newVersionAPI","IDBFactory","prototype","deleteDatabase","sequenceStore","SqlCommands","context","providerConfiguration","typeSystem","extend","databaseName","defaults","defaultDatabaseName","version","dbCreation","storageProviders","DbCreationType","DropTableIfChanged","memoryOperations","_setupExtensionMethods","originalContext","getType","supportedBinaryOperators","value","equal","mapTo","dataType","Boolean","notEqual","equalTyped","notEqualTyped","greaterThan","greaterThanOrEqual","lessThan","lessThenOrEqual","or","and","supportedSetOperations","toArray","forEach","enumerable","writable","supportedFieldOperations","supportedUnaryOperators","idbRequest","idbTran","idbOpenDBRequest","setCallbacks","callbackSettings","Guard","raise","Exception","supportedDataTypes","Integer","Number","Date","String","Object","Guid","Byte","SByte","Decimal","Float","Int16","Int32","Int64","Duration","Day","Time","DateTimeOffset","fieldConverter","supportedAutoincrementKeys","createGuid","_getObjectStoreDefinition","setDefinition","contextStore","storeName","TableName","keyFields","PhysicalType","memberDefinitions","getKeyProperties","error","name","some","memDef","computed","typeName","resolveName","type","console","log","_getObjectStoreDefinitions","objectStoreDefinitions","_storageModel","objectStoreDefinition","push","_oldCreateDB","setVersionTran","definitions","onready","db","onversionchange","event","target","close","_createDB","oncomplete","dropIfExists","objectStoreNames","contains","deleteObjectStore","storeDef","settings","keyPath","autoIncrement","key","createObjectStore","_hasDbChanges","dropTabes","isOriginal","onupgradeneeded","result","hasTableChanges","DropAllExistingTables","initializeStore","callBack","PromiseHandlerBase","createCallbackSettings","initializeMemoryStore","success","open","onsuccess","setVersion","parseInt","onerror","onblocked","onabort","operationProvider","onReady","storageProvider","_initializeStore","initDb","ret","newSequences","createStore","osParam","keySettings","_getKeySettings","openCallbacks","store","transaction","objectStore","clear","item","versionRequest","evt","executeQuery","query","entitySet","getEntitySetFromElementType","defaultType","tableName","dataSource","rawDataList","expression","nodeType","Expressions","ExpressionType","Count","cnt","modelBinderCompiler","createModelBinderConfigCompiler","Visit","openCursor","cursor","count","keys","getPublicMappedProperties","saveChanges","changedItems","saveNextIndependentBlock","independentBlocks","KeySettingsCache","cache","getSettingsForItem","data","fullName","hasOwnProperty","getStorageModel","currentBlock","shift","storesObj","convertedItems","map","physicalData","elementType","keyValue","inverseProperty","concurrencyMode","entityState","EntityState","Added","changedProperties","def","stores","tran","errorCode","ABORT_ERR","ksCache","itemKeys","cursorAction","action","only","ex","abort","add","Deleted","Modified","update","Unchanged","buildIndependentBlocks","_compile","sqlText","createIndexedDBCompiler","compile","isSupported","get","set","indexedDb","IndexedDBStorageProvider","registerProvider","3","defineProperty","_IndexedDBConverter","_IndexedDBStorageProvider","./IndexedDBConverter.js","./IndexedDBStorageProvider.js"],"mappings":"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","file":"IndexedDbProvider.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","﻿// JayData 1.5.5 RC\r\n// Dual licensed under MIT and GPL v2\r\n// Copyright JayStack Technologies (http://jaydata.org/licensing)\r\n//\r\n// JayData is a standards-based, cross-platform Javascript library and a set of\r\n// practices to access and manipulate data from various online and offline sources.\r\n//\r\n// Credits:\r\n//     Hajnalka Battancs, Dániel József, János Roden, László Horváth, Péter Nochta\r\n//     Péter Zentai, Róbert Bónay, Szabolcs Czinege, Viktor Borza, Viktor Lázár,\r\n//     Zoltán Gyebrovszki, Gábor Dolla\r\n//\r\n// More info: http://jaydata.org\r\n(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define(\"jaydata/indexeddb\",[\"jaydata/core\"],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.$data = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n'use strict';\n\nvar _core = _dereq_('jaydata/core');\n\nvar _core2 = _interopRequireDefault(_core);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_core2.default.IndexedDBConverter = {\n    fromDb: {\n        '$data.Enum': function $dataEnum(v, enumType) {\n            return _core2.default.Container.convertTo(v, enumType);\n        },\n        '$data.Byte': _core2.default.Container.proxyConverter,\n        '$data.SByte': _core2.default.Container.proxyConverter,\n        '$data.Decimal': _core2.default.Container.proxyConverter,\n        '$data.Float': _core2.default.Container.proxyConverter,\n        '$data.Int16': _core2.default.Container.proxyConverter,\n        '$data.Int64': _core2.default.Container.proxyConverter,\n        '$data.Integer': _core2.default.Container.proxyConverter,\n        '$data.Int32': _core2.default.Container.proxyConverter,\n        '$data.Number': _core2.default.Container.proxyConverter,\n        '$data.Date': _core2.default.Container.proxyConverter,\n        '$data.DateTimeOffset': _core2.default.Container.proxyConverter,\n        '$data.Duration': _core2.default.Container.proxyConverter,\n        '$data.Day': _core2.default.Container.proxyConverter,\n        '$data.Time': _core2.default.Container.proxyConverter,\n        '$data.String': _core2.default.Container.proxyConverter,\n        '$data.Boolean': _core2.default.Container.proxyConverter,\n        '$data.Blob': function $dataBlob(b) {\n            return b ? _core2.default.Container.convertTo(b, _core2.default.Blob) : b;\n        },\n        '$data.Array': function $dataArray(arr) {\n            if (arr === undefined) {\n                return new _core2.default.Array();\n            }return arr;\n        },\n        '$data.Object': _core2.default.Container.proxyConverter,\n        \"$data.Guid\": function $dataGuid(g) {\n            return g ? _core2.default.parseGuid(g).toString() : g;\n        },\n        '$data.GeographyPoint': function $dataGeographyPoint(g) {\n            if (g) {\n                return new _core2.default.GeographyPoint(g);\n            }return g;\n        },\n        '$data.GeographyLineString': function $dataGeographyLineString(g) {\n            if (g) {\n                return new _core2.default.GeographyLineString(g);\n            }return g;\n        },\n        '$data.GeographyPolygon': function $dataGeographyPolygon(g) {\n            if (g) {\n                return new _core2.default.GeographyPolygon(g);\n            }return g;\n        },\n        '$data.GeographyMultiPoint': function $dataGeographyMultiPoint(g) {\n            if (g) {\n                return new _core2.default.GeographyMultiPoint(g);\n            }return g;\n        },\n        '$data.GeographyMultiLineString': function $dataGeographyMultiLineString(g) {\n            if (g) {\n                return new _core2.default.GeographyMultiLineString(g);\n            }return g;\n        },\n        '$data.GeographyMultiPolygon': function $dataGeographyMultiPolygon(g) {\n            if (g) {\n                return new _core2.default.GeographyMultiPolygon(g);\n            }return g;\n        },\n        '$data.GeographyCollection': function $dataGeographyCollection(g) {\n            if (g) {\n                return new _core2.default.GeographyCollection(g);\n            }return g;\n        },\n        '$data.GeometryPoint': function $dataGeometryPoint(g) {\n            if (g) {\n                return new _core2.default.GeometryPoint(g);\n            }return g;\n        },\n        '$data.GeometryLineString': function $dataGeometryLineString(g) {\n            if (g) {\n                return new _core2.default.GeometryLineString(g);\n            }return g;\n        },\n        '$data.GeometryPolygon': function $dataGeometryPolygon(g) {\n            if (g) {\n                return new _core2.default.GeometryPolygon(g);\n            }return g;\n        },\n        '$data.GeometryMultiPoint': function $dataGeometryMultiPoint(g) {\n            if (g) {\n                return new _core2.default.GeometryMultiPoint(g);\n            }return g;\n        },\n        '$data.GeometryMultiLineString': function $dataGeometryMultiLineString(g) {\n            if (g) {\n                return new _core2.default.GeometryMultiLineString(g);\n            }return g;\n        },\n        '$data.GeometryMultiPolygon': function $dataGeometryMultiPolygon(g) {\n            if (g) {\n                return new _core2.default.GeometryMultiPolygon(g);\n            }return g;\n        },\n        '$data.GeometryCollection': function $dataGeometryCollection(g) {\n            if (g) {\n                return new _core2.default.GeometryCollection(g);\n            }return g;\n        }\n    },\n    toDb: {\n        '$data.Enum': _core2.default.Container.proxyConverter,\n        '$data.Byte': _core2.default.Container.proxyConverter,\n        '$data.SByte': _core2.default.Container.proxyConverter,\n        '$data.Decimal': _core2.default.Container.proxyConverter,\n        '$data.Float': _core2.default.Container.proxyConverter,\n        '$data.Int16': _core2.default.Container.proxyConverter,\n        '$data.Int64': _core2.default.Container.proxyConverter,\n        '$data.Integer': _core2.default.Container.proxyConverter,\n        '$data.Int32': _core2.default.Container.proxyConverter,\n        '$data.Number': _core2.default.Container.proxyConverter,\n        '$data.Date': _core2.default.Container.proxyConverter,\n        '$data.DateTimeOffset': _core2.default.Container.proxyConverter,\n        '$data.Duration': _core2.default.Container.proxyConverter,\n        '$data.Day': _core2.default.Container.proxyConverter,\n        '$data.Time': _core2.default.Container.proxyConverter,\n        '$data.String': _core2.default.Container.proxyConverter,\n        '$data.Boolean': _core2.default.Container.proxyConverter,\n        '$data.Blob': function $dataBlob(b) {\n            return b ? _core2.default.Blob.toString(b) : b;\n        },\n        '$data.Array': function $dataArray(arr) {\n            return arr ? JSON.parse(JSON.stringify(arr)) : arr;\n        },\n        '$data.Object': _core2.default.Container.proxyConverter,\n        \"$data.Guid\": function $dataGuid(g) {\n            return g ? g.toString() : g;\n        },\n        '$data.GeographyPoint': function $dataGeographyPoint(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeographyLineString': function $dataGeographyLineString(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeographyPolygon': function $dataGeographyPolygon(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeographyMultiPoint': function $dataGeographyMultiPoint(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeographyMultiLineString': function $dataGeographyMultiLineString(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeographyMultiPolygon': function $dataGeographyMultiPolygon(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeographyCollection': function $dataGeographyCollection(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeometryPoint': function $dataGeometryPoint(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeometryLineString': function $dataGeometryLineString(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeometryPolygon': function $dataGeometryPolygon(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeometryMultiPoint': function $dataGeometryMultiPoint(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeometryMultiLineString': function $dataGeometryMultiLineString(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeometryMultiPolygon': function $dataGeometryMultiPolygon(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeometryCollection': function $dataGeometryCollection(g) {\n            if (g) {\n                return g;\n            }return g;\n        }\n    }\n};\n\n},{\"jaydata/core\":\"jaydata/core\"}],2:[function(_dereq_,module,exports){\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _core = _dereq_('jaydata/core');\n\nvar _core2 = _interopRequireDefault(_core);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_core2.default.Class.define('$data.storageProviders.indexedDb.IndexedDBStorageProvider', _core2.default.StorageProviderBase, null, {\n    constructor: function constructor(cfg, ctxInstance) {\n        // mapping IndexedDB types to browser invariant name\n        this.indexedDB = _core2.default.__global.indexedDB || _core2.default.__global.webkitIndexedDB || _core2.default.__global.mozIndexedDB || _core2.default.__global.msIndexedDB;\n        this.IDBRequest = _core2.default.__global.IDBRequest || _core2.default.__global.webkitIDBRequest || _core2.default.__global.mozIDBRequest || _core2.default.__global.msIDBRequest;\n        this.IDBTransaction = _core2.default.__global.IDBTransaction || _core2.default.__global.webkitIDBTransaction || _core2.default.__global.mozIDBTransaction || _core2.default.__global.msIDBTransaction;\n        this.IDBTransactionType = { READ_ONLY: \"readonly\", READ_WRITE: \"readwrite\", VERSIONCHANGE: \"versionchange\" };\n        if (typeof this.IDBTransaction.READ_ONLY !== 'undefined' && typeof this.IDBTransaction.READ_WRITE !== 'undefined') {\n            this.IDBTransactionType.READ_ONLY = this.IDBTransaction.READ_ONLY;\n            this.IDBTransactionType.READ_WRITE = this.IDBTransaction.READ_WRITE;\n        }\n\n        this.IDBKeyRange = _core2.default.__global.IDBKeyRange || _core2.default.__global.webkitIDBKeyRange || _core2.default.__global.mozIDBKeyRange || _core2.default.__global.msIDBKeyRange;\n        this.IDBDatabaseException = _core2.default.__global.IDBDatabaseException || _core2.default.__global.webkitIDBDatabaseException || _core2.default.__global.mozIDBDatabaseException || _core2.default.__global.msIDBDatabaseException;\n        this.IDBOpenDBRequest = _core2.default.__global.IDBOpenDBRequest || _core2.default.__global.webkitIDBOpenDBRequest || _core2.default.__global.mozIDBOpenDBRequest || _core2.default.__global.msIDBOpenDBRequest;\n        this.newVersionAPI = !!(_core2.default.__global.IDBFactory && IDBFactory.prototype.deleteDatabase);\n        this.sequenceStore = '__jayData_sequence';\n        this.SqlCommands = [];\n        this.context = {};\n        this.providerConfiguration = _core2.default.typeSystem.extend({\n            databaseName: _core2.default.defaults.defaultDatabaseName,\n            version: 1,\n            dbCreation: _core2.default.storageProviders.DbCreationType.DropTableIfChanged,\n            memoryOperations: true\n        }, cfg);\n        this._setupExtensionMethods();\n\n        if (ctxInstance) this.originalContext = ctxInstance.getType();\n    },\n    supportedBinaryOperators: {\n        value: {\n            equal: { mapTo: ' == ', dataType: _core2.default.Boolean },\n            notEqual: { mapTo: ' != ', dataType: _core2.default.Boolean },\n            equalTyped: { mapTo: ' == ', dataType: _core2.default.Boolean },\n            notEqualTyped: { mapTo: ' != ', dataType: _core2.default.Boolean },\n            greaterThan: { mapTo: ' > ', dataType: _core2.default.Boolean },\n            greaterThanOrEqual: { mapTo: ' >= ', dataType: _core2.default.Boolean },\n\n            lessThan: { mapTo: ' < ', dataType: _core2.default.Boolean },\n            lessThenOrEqual: { mapTo: ' <= ', dataType: _core2.default.Boolean },\n            or: { mapTo: ' || ', dataType: _core2.default.Boolean },\n            and: { mapTo: ' && ', dataType: _core2.default.Boolean }\n            //'in': { mapTo: ' in ', dataType: $data.Boolean, resolvableType: [$data.Array, $data.Queryable] }\n        }\n    },\n    supportedSetOperations: {\n        value: {\n            length: {},\n            toArray: {},\n            forEach: {}\n        },\n        enumerable: true,\n        writable: true\n    },\n    supportedFieldOperations: {\n        value: {},\n        enumerable: true,\n        writable: true\n    },\n    supportedUnaryOperators: {\n        value: {},\n        enumerable: true,\n        writable: true\n    },\n    _setupExtensionMethods: function _setupExtensionMethods() {\n        /// <summary>\n        /// Sets the extension method 'setCallback' on IDBRequest, IDBOpenDBRequest, and IDBTransaction types\n        /// </summary>\n        var self = this;\n        var idbRequest = this.IDBRequest;\n        var idbTran = this.IDBTransaction;\n        var idbOpenDBRequest = this.IDBOpenDBRequest;\n        var setCallbacks = function setCallbacks(callbackSettings) {\n            /// <summary>\n            /// Sets the callbacks on the object.\n            /// </summary>\n            /// <param name=\"callbackSettings\">Named value pairs of the callbacks</param>\n            if ((typeof callbackSettings === 'undefined' ? 'undefined' : _typeof(callbackSettings)) !== 'object') _core.Guard.raise(new _core.Exception('Invalid callbackSettings', null, callbackSettings));\n            for (var i in callbackSettings) {\n                if (typeof this[i] === 'undefined' || typeof callbackSettings[i] !== 'function') continue;\n                this[i] = callbackSettings[i];\n            }\n\n            //if (this.readyState == self.IDBRequest.DONE)\n            //    console.log('WARNING: request finished before setCallbacks. Do not use breakpoints between creating the request object and finishing the setting of callbacks');\n            return this;\n        };\n        if (idbRequest && typeof idbRequest.prototype.setCallbacks !== 'function') idbRequest.prototype.setCallbacks = setCallbacks;\n        if (idbTran && typeof idbTran.prototype.setCallbacks !== 'function') idbTran.prototype.setCallbacks = setCallbacks;\n        if (idbOpenDBRequest && typeof idbOpenDBRequest.prototype.setCallbacks !== 'function') idbOpenDBRequest.prototype.setCallbacks = setCallbacks;\n    },\n    supportedDataTypes: {\n        value: [_core2.default.Integer, _core2.default.Number, _core2.default.Date, _core2.default.String, _core2.default.Boolean, _core2.default.Blob, _core2.default.Array, _core2.default.Object, _core2.default.Guid, _core2.default.GeographyPoint, _core2.default.GeographyLineString, _core2.default.GeographyPolygon, _core2.default.GeographyMultiPoint, _core2.default.GeographyMultiLineString, _core2.default.GeographyMultiPolygon, _core2.default.GeographyCollection, _core2.default.GeometryPoint, _core2.default.GeometryLineString, _core2.default.GeometryPolygon, _core2.default.GeometryMultiPoint, _core2.default.GeometryMultiLineString, _core2.default.GeometryMultiPolygon, _core2.default.GeometryCollection, _core2.default.Byte, _core2.default.SByte, _core2.default.Decimal, _core2.default.Float, _core2.default.Int16, _core2.default.Int32, _core2.default.Int64, _core2.default.Duration, _core2.default.Day, _core2.default.Time, _core2.default.DateTimeOffset],\n        writable: false\n    },\n    fieldConverter: { value: _core2.default.IndexedDBConverter },\n\n    supportedAutoincrementKeys: {\n        value: {\n            '$data.Integer': true,\n            '$data.Int32': true,\n            '$data.Guid': function $dataGuid() {\n                return _core2.default.createGuid();\n            }\n        }\n    },\n\n    _getObjectStoreDefinition: function _getObjectStoreDefinition(setDefinition) {\n        var contextStore = {\n            storeName: setDefinition.TableName\n        };\n        var keyFields = setDefinition.PhysicalType.memberDefinitions.getKeyProperties();\n\n        if (0 == keyFields.length) {\n            var error = new Error(\"Entity must have a key field: \" + contextStore.storeName);\n            error.name = \"KeyNotFoundError\";\n            throw error;\n        }\n        /*if (1 != keyFields.length) {\r\n            var error = new Error(\"Entity must have only one key field: \" + contextStore.storeName);\r\n            error.name = \"MultipleKeysNotSupportedError\";\r\n            throw error;\r\n        }*/\n        //var keyField = keyFields[0];\n        /*for (var i = 0; i < keyFields.length; i++) {\r\n              if (keyFields[i].computed === true &&\r\n                (\"$data.Integer\" !== Container.resolveName(keyFields[i].type))) {\r\n                var error = new Error(\"Computed key field must be of integer type: \" + contextStore.storeName);\r\n                error.name = \"ComputedKeyFieldError\";\r\n                throw error;\r\n            }\r\n            if (keyFields.length > 2 && keyFields[i].computed) {\r\n                var error = new Error(\"With multiple keys the computed field is not allowed: \" + contextStore.storeName);\r\n                error.name = \"MultipleComputedKeyFieldError\";\r\n                throw error;\r\n            }\r\n        }*/\n\n        if (keyFields.length > 2 && keyFields.some(function (memDef) {\n            return memDef.computed;\n        })) {\n            _core.Guard.raise(\"With multiple keys the computed field is not allowed: \" + contextStore.storeName, \"MultipleComputedKeyFieldError\");\n        }\n\n        for (var i = 0; i < keyFields.length; i++) {\n            var typeName = _core.Container.resolveName(keyFields[i].type);\n            if (keyFields[i].computed && !this.supportedAutoincrementKeys[typeName]) {\n                console.log(\"WARRNING! '\" + typeName + \"' not supported as computed Key!\");\n            }\n        }\n\n        contextStore.keyFields = keyFields;\n        return contextStore;\n    },\n\n    _getObjectStoreDefinitions: function _getObjectStoreDefinitions() {\n        var objectStoreDefinitions = [];\n        var self = this;\n        self.context._storageModel.forEach(function (memDef) {\n            var objectStoreDefinition = self._getObjectStoreDefinition(memDef);\n            objectStoreDefinitions.push(objectStoreDefinition);\n        });\n        return objectStoreDefinitions;\n    },\n\n    _oldCreateDB: function _oldCreateDB(setVersionTran, definitions, onready) {\n        var self = this;\n        setVersionTran.db.onversionchange = function (event) {\n            return event.target.close();\n        };\n\n        self._createDB(setVersionTran.db, definitions);\n        setVersionTran.oncomplete = onready;\n    },\n    _createDB: function _createDB(db, definitions) {\n        for (var i = 0; i < definitions.length; i++) {\n            if (definitions[i].dropIfExists && db.objectStoreNames.contains(definitions[i].storeName)) {\n                db.deleteObjectStore(definitions[i].storeName);\n            }\n        }\n\n        for (var i = 0; i < definitions.length; i++) {\n            var storeDef = definitions[i];\n\n            if (!db.objectStoreNames.contains(storeDef.storeName)) {\n                var settings = {};\n                if (storeDef.keyFields.length == 1) {\n                    settings = {\n                        keyPath: storeDef.keyFields[0].name\n                        //autoIncrement: storeDef.keyFields[0].computed\n                    };\n                    var typeName = _core.Container.resolveName(storeDef.keyFields[0].type);\n                    settings.autoIncrement = this.supportedAutoincrementKeys[typeName] ? true : false;\n                } else {\n                    settings.key = [];\n                    for (var i = 0; i < storeDef.keyFields.length; i++) {\n                        settings.key.push(storeDef.keyFields[i].name);\n                    }\n                }\n                db.createObjectStore(storeDef.storeName, settings);\n            }\n        }\n    },\n    _hasDbChanges: function _hasDbChanges(db, definitions, dropTabes) {\n        var isOriginal = true;\n        for (var i = 0; i < definitions.length; i++) {\n            isOriginal = isOriginal && db.objectStoreNames.contains(definitions[i].storeName);\n\n            if (dropTabes) {\n                definitions[i].dropIfExists = true;\n                isOriginal = false;\n            }\n        }\n\n        return !isOriginal;\n    },\n    onupgradeneeded: function onupgradeneeded(objectStoreDefinitions) {\n        var self = this;\n        return function (e) {\n            var db = e.target.result;\n            db.onversionchange = function (event) {\n                return event.target.close();\n            };\n            var hasTableChanges = self._hasDbChanges(db, objectStoreDefinitions, self.providerConfiguration.dbCreation == _core2.default.storageProviders.DbCreationType.DropAllExistingTables);\n            if (hasTableChanges) self._createDB(db, objectStoreDefinitions);\n        };\n    },\n\n    initializeStore: function initializeStore(callBack) {\n        callBack = _core2.default.PromiseHandlerBase.createCallbackSettings(callBack);\n        var self = this;\n\n        this.initializeMemoryStore({\n            success: function success() {\n                var objectStoreDefinitions;\n                try {\n                    objectStoreDefinitions = self._getObjectStoreDefinitions();\n                } catch (e) {\n                    console.log(objectStoreDefinitions);\n                    callBack.error(e);\n                    return;\n                }\n                self.indexedDB.open(self.providerConfiguration.databaseName).setCallbacks({\n                    onsuccess: function onsuccess(e) {\n                        var db = e.target.result;\n                        db.onversionchange = function (event) {\n                            return event.target.close();\n                        };\n\n                        var hasTableChanges = self._hasDbChanges(db, objectStoreDefinitions, self.providerConfiguration.dbCreation == _core2.default.storageProviders.DbCreationType.DropAllExistingTables);\n                        //oldAPI\n                        if (db.setVersion) {\n                            if (db.version === \"\" || hasTableChanges) {\n                                db.setVersion((parseInt(db.version) || 0) + 1).setCallbacks({\n                                    onsuccess: function onsuccess(e) {\n                                        var db = e.target.result;\n                                        self._oldCreateDB(db /*setVerTran*/, objectStoreDefinitions, function (e) {\n                                            self.db = e.target.db;\n                                            callBack.success(self.context);\n                                        });\n                                    },\n                                    onerror: function onerror() {\n                                        var v = arguments;\n                                    },\n                                    onblocked: function onblocked() {\n                                        var v = arguments;\n                                    }\n                                });\n                                return;\n                            };\n                        } else if (hasTableChanges) {\n                            //newVersionAPI\n                            db.close();\n                            var version = parseInt(db.version) + 1;\n                            self.indexedDB.open(self.providerConfiguration.databaseName, version).setCallbacks({\n                                onsuccess: function onsuccess(e) {\n                                    self.db = e.target.result;\n                                    callBack.success(self.context);\n                                },\n                                onupgradeneeded: self.onupgradeneeded(objectStoreDefinitions),\n                                onerror: callBack.error,\n                                onabort: callBack.error,\n                                onblocked: callBack.error\n                            });\n                            return;\n                        }\n\n                        self.db = db;\n                        callBack.success(self.context);\n                    },\n                    //newVersionAPI\n                    onupgradeneeded: self.onupgradeneeded(objectStoreDefinitions),\n                    onerror: callBack.error,\n                    onabort: callBack.error,\n                    onblocked: callBack.error\n                });\n            },\n            error: callBack.error\n        });\n    },\n    initializeMemoryStore: function initializeMemoryStore(callBack) {\n        callBack = _core2.default.PromiseHandlerBase.createCallbackSettings(callBack);\n        var self = this;\n\n        if (self.originalContext && self.providerConfiguration.memoryOperations) {\n            self.operationProvider = new self.originalContext({ name: 'InMemory' });\n            self.operationProvider.onReady({\n                success: function success() {\n                    self.supportedBinaryOperators = self.operationProvider.storageProvider.supportedBinaryOperators;\n                    self.supportedSetOperations = self.operationProvider.storageProvider.supportedSetOperations;\n                    self.supportedFieldOperations = self.operationProvider.storageProvider.supportedFieldOperations;\n                    self.supportedUnaryOperators = self.operationProvider.storageProvider.supportedUnaryOperators;\n                    callBack.success();\n                },\n                error: callBack.error\n            });\n        } else {\n            callBack.success();\n        }\n    },\n\n    _initializeStore: function _initializeStore(callBack) {\n        callBack = _core2.default.PromiseHandlerBase.createCallbackSettings(callBack);\n        var self = this;\n\n        var initDb = function initDb(db) {\n            db.onversionchange = function (event) {\n                var ret = event.target.close();\n                return ret;\n            };\n            var newSequences = [];\n            self.context._storageModel.forEach(function (memDef) {\n                function createStore() {\n                    /// <summary>\n                    /// Creates a store for 'memDef'\n                    /// </summary>\n                    var osParam = {};\n                    var keySettings = self._getKeySettings(memDef);\n                    if (self.newVersionAPI) {\n                        if (keySettings.autoIncrement) newSequences.push(memDef.TableName);\n                    } else {\n                        osParam.autoIncrement = keySettings.autoIncrement;\n                    }\n                    if (keySettings.keyPath !== undefined) osParam.keyPath = keySettings.keyPath;\n                    db.createObjectStore(memDef.TableName, osParam);\n                }\n                if (db.objectStoreNames.contains(memDef.TableName)) {\n                    // ObjectStore already present.\n                    if (self.providerConfiguration.dbCreation === _core2.default.storageProviders.DbCreationType.DropAllExistingTables) {\n                        // Force drop and recreate object store\n                        db.deleteObjectStore(memDef.TableName);\n                        createStore();\n                    }\n                } else {\n                    // Store does not exists yet, we need to create it\n                    createStore();\n                }\n            });\n            if (newSequences.length > 0 && !db.objectStoreNames.contains(self.sequenceStore)) {\n                // Sequence store does not exists yet, we create it\n                db.createObjectStore(self.sequenceStore, { keyPath: 'store' });\n                newSequences = [];\n            }\n            return newSequences;\n        };\n        var newSequences = null;\n        // Creating openCallbacks settings for both type of db.open() method\n        var openCallbacks = {\n            onupgradeneeded: function onupgradeneeded(event) {\n                newSequences = initDb(event.target.result);\n            },\n            onerror: callBack.error,\n            onblocked: callBack.error,\n            onsuccess: function onsuccess(event) {\n                self.db = event.target.result;\n                self.db.onversionchange = function (event) {\n                    event.target.close();\n                };\n                if (self.newVersionAPI) {\n                    if (newSequences && newSequences.length > 0) {\n                        var store = self.db.transaction([self.sequenceStore], self.IDBTransactionType.READ_WRITE).setCallbacks({\n                            onerror: callBack.error,\n                            oncomplete: function oncomplete() {\n                                callBack.success(self.context);\n                            }\n                        }).objectStore(self.sequenceStore);\n                        switch (self.providerConfiguration.dbCreation) {\n                            case _core2.default.storageProviders.DbCreationType.DropAllExistingTables:\n                            case _core2.default.storageProviders.DbCreationType.DropTableIfChanged:\n                                // Clearing all data\n                                store.clear();\n                                break;\n                            default:\n                                // Removing data for newly created stores, if they previously existed\n                                newSequences.forEach(function (item) {\n                                    store['delete'](item);\n                                });\n                                break;\n                        }\n                    }\n                    callBack.success(self.context);\n                } else {\n                    // Calling setVersion on webkit\n                    var versionRequest = self.db.setVersion(self.providerConfiguration.version.toString()).setCallbacks({\n                        onerror: callBack.error,\n                        onblocked: callBack.error,\n                        onsuccess: function onsuccess(event) {\n                            initDb(self.db);\n                            versionRequest.result.oncomplete = function (evt) {\n                                callBack.success(self.context);\n                            };\n                        }\n                    });\n                }\n            }\n        };\n        // For Firefox we need to pass the version here\n        if (self.newVersionAPI) self.indexedDB.open(self.providerConfiguration.databaseName, parseInt(self.providerConfiguration.version, 10)).setCallbacks(openCallbacks);else self.indexedDB.open(self.providerConfiguration.databaseName).setCallbacks(openCallbacks);\n    },\n\n    executeQuery: function executeQuery(query, callBack) {\n        callBack = _core2.default.PromiseHandlerBase.createCallbackSettings(callBack);\n        var self = this;\n\n        //var compiledQuery = self._compile(query);\n\n        // Creating read only transaction for query. Results are passed in transaction's oncomplete event\n        var entitySet = query.context.getEntitySetFromElementType(query.defaultType);\n        var store = self.db.transaction([entitySet.tableName], self.IDBTransactionType.READ_ONLY).setCallbacks({\n            onerror: callBack.error,\n            onabort: callBack.error,\n            oncomplete: function oncomplete(event) {\n                if (self.operationProvider) {\n                    self.operationProvider.storageProvider.dataSource[entitySet.tableName] = query.rawDataList;\n                    self.operationProvider.storageProvider.executeQuery(query, {\n                        success: function success(query) {\n                            if (query.expression.nodeType === _core2.default.Expressions.ExpressionType.Count) {\n                                query.rawDataList[0] = { cnt: query.rawDataList[0] };\n                            }\n                            callBack.success(query);\n                        },\n                        error: callBack.error\n                    });\n                } else {\n                    callBack.success(query);\n                }\n            }\n        }).objectStore(entitySet.tableName);\n        var modelBinderCompiler = _core.Container.createModelBinderConfigCompiler(query, []);\n        modelBinderCompiler.Visit(query.expression);\n\n        if (self.operationProvider) {\n            store.openCursor().onsuccess = function (event) {\n                // We currently support only toArray() so let's just dump all data\n                var cursor = event.target.result;\n                if (cursor) {\n                    var value = cursor.value;\n                    query.rawDataList.push(cursor.value);\n                    cursor['continue']();\n                }\n            };\n        } else {\n            switch (query.expression.nodeType) {\n                case _core2.default.Expressions.ExpressionType.Count:\n                    store.count().onsuccess = function (event) {\n                        var count = event.target.result;\n                        query.rawDataList.push({ cnt: count });\n                    };\n                    break;\n                default:\n                    store.openCursor().onsuccess = function (event) {\n                        // We currently support only toArray() so let's just dump all data\n                        var cursor = event.target.result;\n                        if (cursor) {\n                            var value = cursor.value;\n                            query.rawDataList.push(cursor.value);\n                            cursor['continue']();\n                        }\n                    };\n                    break;\n            }\n        };\n    },\n    _getKeySettings: function _getKeySettings(memDef) {\n        /// <summary>\n        /// Gets key settings for item type's member definition\n        /// </summary>\n        /// <param name=\"memDef\">memDef of item</param>\n        /// <returns>KeySettings object</returns>\n        var self = this;\n        var settings = { autoIncrement: false };\n        var keys = [];\n        memDef.PhysicalType.memberDefinitions.getPublicMappedProperties().forEach(function (item) {\n            if (item.key) {\n                // We found a key\n                keys.push(item.name);\n            }\n            if (item.computed) {\n                // AutoIncrement field, must be key\n                if (!item.key) _core.Guard.raise(new _core.Exception('Only key field can be a computed field!'));\n\n                var typeName = _core.Container.resolveName(item.type);\n                if (self.supportedAutoincrementKeys[typeName] === true) {\n                    settings.autoIncrement = true;\n                }\n            }\n        });\n        if (keys.length > 1) {\n            if (settings.autoIncrement) _core.Guard.raise(new _core.Exception('Auto increment is only valid for a single key!'));\n            // Setting key fields (composite key)\n            settings.keys = keys;\n        } else if (keys.length == 1) {\n            // Simple key\n            settings.keyPath = keys[0];\n        } else {\n            _core.Guard.raise(new _core.Exception('No valid key found!'));\n        }\n        return settings;\n    },\n    saveChanges: function saveChanges(callBack, changedItems) {\n        var self = this;\n        // Building independent blocks and processing them sequentially\n        var independentBlocks = self.buildIndependentBlocks(changedItems);\n        function saveNextIndependentBlock() {\n            /// <summary>\n            /// Saves the next independent block\n            /// </summary>\n            if (independentBlocks.length === 0) {\n                // No more blocks left, calling success callback\n                callBack.success();\n            } else {\n                var KeySettingsCache = function KeySettingsCache() {\n                    /// <summary>\n                    /// Simple cache for key settings of types\n                    /// </summary>\n                    var cache = {};\n                    this.getSettingsForItem = function (item) {\n                        var typeName = item.data.getType().fullName;\n                        if (!cache.hasOwnProperty(typeName)) {\n                            cache[typeName] = self._getKeySettings(self.context._storageModel.getStorageModel(item.data.getType()));\n                        }\n                        return cache[typeName];\n                    };\n                };\n\n                // 'Popping' next block\n                var currentBlock = independentBlocks.shift();\n                // Collecting stores of items for transaction initialize\n                var storesObj = {};\n                // Generating physicalData\n                var convertedItems = currentBlock.map(function (item) {\n                    storesObj[item.entitySet.tableName] = true;\n                    item.physicalData = {};\n                    item.entitySet.elementType.memberDefinitions.getPublicMappedProperties().forEach(function (memDef) {\n                        var typeName = _core.Container.resolveName(memDef.type);\n                        if (memDef.key && memDef.computed && item.data[memDef.name] == undefined) {\n                            if (typeof self.supportedAutoincrementKeys[typeName] === 'function') {\n                                var keyValue = self.supportedAutoincrementKeys[typeName]();\n                                item.data[memDef.name] = self.fieldConverter.toDb[typeName](keyValue);\n                            } else {\n                                // Autogenerated fields for new items should not be present in the physicalData\n                                return;\n                            }\n                        }\n                        if (!memDef.inverseProperty && typeof memDef.concurrencyMode === 'undefined' && (memDef.key === true || item.data.entityState === _core2.default.EntityState.Added || item.data.changedProperties && item.data.changedProperties.some(function (def) {\n                            return def.name === memDef.name;\n                        }))) {\n                            if (self.fieldConverter.toDb[typeName]) {\n                                item.physicalData[memDef.name] = self.fieldConverter.toDb[typeName](item.data[memDef.name]);\n                            } else {\n                                var value = item.data[memDef.name];\n                                if (value !== undefined) {\n                                    value = JSON.parse(JSON.stringify(value));\n                                }\n                                item.physicalData[memDef.name] = value;\n                            }\n                        }\n                    });\n                    return item;\n                });\n                var stores = [];\n                for (var i in storesObj) {\n                    stores.push(i);\n                }\n                var tran = self.db.transaction(stores, self.IDBTransactionType.READ_WRITE).setCallbacks({\n                    onerror: function onerror(event) {\n                        // Only call the error callback when it's not because of an abort\n                        // aborted cases should call the error callback there\n                        if (!event.target || !self.IDBDatabaseException || event.target && self.IDBDatabaseException && event.target.errorCode !== self.IDBDatabaseException.ABORT_ERR) callBack.error(event);\n                    },\n                    oncomplete: function oncomplete(event) {\n                        // Moving to next block\n                        saveNextIndependentBlock();\n                    }\n                });\n\n                var ksCache = new KeySettingsCache();\n                convertedItems.forEach(function (item) {\n                    // Getting store and keysettings for the current item\n                    var store = tran.objectStore(item.entitySet.tableName);\n                    var keySettings = ksCache.getSettingsForItem(item);\n                    // Contains the keys that should be passed for create, update and delete (composite keys)\n                    var itemKeys = keySettings.keys && keySettings.keys.map(function (key) {\n                        return item.physicalData[key];\n                    }) || null;\n                    try {\n                        var cursorAction = function cursorAction(action) {\n                            /// <summary>\n                            /// Find the current item in the store, and calls the action on it. Error raised when item was not found\n                            /// </summary>\n                            /// <param name=\"action\">Action to call on the item</param>\n                            var key = keySettings.keyPath ? item.physicalData[keySettings.keyPath] : itemKeys;\n                            var data = item.physicalData;\n                            store.openCursor(self.IDBKeyRange.only(key)).onsuccess = function (event) {\n                                try {\n                                    var cursor = event.target.result;\n                                    if (cursor) action(cursor, key, data);else _core.Guard.raise(new _core.Exception('Object not found', null, item));\n                                } catch (ex) {\n                                    tran.abort();\n                                    callBack.error(ex);\n                                }\n                            };\n                        };\n                        switch (item.data.entityState) {\n                            case _core2.default.EntityState.Added:\n                                if (!keySettings.keyPath) {\n                                    // Item needs explicit keys\n                                    store.add(item.physicalData, itemKeys);\n                                } else {\n                                    store.add(item.physicalData).onsuccess = function (event) {\n                                        // Saves the generated key back to the entity\n                                        item.data[keySettings.keyPath] = event.target.result;\n                                    };\n                                }\n                                break;\n                            case _core2.default.EntityState.Deleted:\n                                // Deletes the item\n                                cursorAction(function (cursor) {\n                                    cursor['delete']();\n                                });\n                                break;\n                            case _core2.default.EntityState.Modified:\n                                // Updates the item\n                                cursorAction(function (cursor, key, data) {\n                                    cursor.update(_core2.default.typeSystem.extend(cursor.value, data));\n                                });\n                                break;\n                            case _core2.default.EntityState.Unchanged:\n                                break;\n                            default:\n                                _core.Guard.raise(new _core.Exception('Not supported entity state', null, item));\n                        }\n                    } catch (ex) {\n                        // Abort on exceptions\n                        tran.abort();\n                        callBack.error(ex);\n                    }\n                });\n            }\n        }\n        saveNextIndependentBlock();\n    },\n    _compile: function _compile(query) {\n        var sqlText = _core.Container.createIndexedDBCompiler().compile(query);\n        return sqlText;\n    }\n}, {\n    isSupported: {\n        get: function get() {\n            return _core2.default.__global.indexedDB || _core2.default.__global.webkitIndexedDB || _core2.default.__global.mozIndexedDB || _core2.default.__global.msIndexedDB ? true : false;\n        },\n        set: function set() {}\n    }\n});\n\nif (_core2.default.storageProviders.indexedDb.IndexedDBStorageProvider.isSupported) _core2.default.StorageProviderBase.registerProvider('indexedDb', _core2.default.storageProviders.indexedDb.IndexedDBStorageProvider);\n\n},{\"jaydata/core\":\"jaydata/core\"}],3:[function(_dereq_,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _core = _dereq_('jaydata/core');\n\nvar _core2 = _interopRequireDefault(_core);\n\nvar _IndexedDBConverter = _dereq_('./IndexedDBConverter.js');\n\nvar _IndexedDBConverter2 = _interopRequireDefault(_IndexedDBConverter);\n\nvar _IndexedDBStorageProvider = _dereq_('./IndexedDBStorageProvider.js');\n\nvar _IndexedDBStorageProvider2 = _interopRequireDefault(_IndexedDBStorageProvider);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _core2.default;\nmodule.exports = exports['default'];\n\n},{\"./IndexedDBConverter.js\":1,\"./IndexedDBStorageProvider.js\":2,\"jaydata/core\":\"jaydata/core\"}]},{},[3])(3)\n});\n\n","import $data, { $C, Guard, Container, Exception, MemberDefinition } from 'jaydata/core';\r\n\r\n$data.IndexedDBConverter = {\r\n    fromDb: {\r\n        '$data.Enum': function(v, enumType) { return $data.Container.convertTo(v, enumType); },\r\n        '$data.Byte': $data.Container.proxyConverter,\r\n        '$data.SByte': $data.Container.proxyConverter,\r\n        '$data.Decimal': $data.Container.proxyConverter,\r\n        '$data.Float': $data.Container.proxyConverter,\r\n        '$data.Int16': $data.Container.proxyConverter,\r\n        '$data.Int64': $data.Container.proxyConverter,\r\n        '$data.Integer': $data.Container.proxyConverter,\r\n        '$data.Int32': $data.Container.proxyConverter,\r\n        '$data.Number': $data.Container.proxyConverter,\r\n        '$data.Date': $data.Container.proxyConverter,\r\n        '$data.DateTimeOffset': $data.Container.proxyConverter,\r\n        '$data.Duration': $data.Container.proxyConverter,\r\n        '$data.Day': $data.Container.proxyConverter,\r\n        '$data.Time': $data.Container.proxyConverter,\r\n        '$data.String': $data.Container.proxyConverter,\r\n        '$data.Boolean': $data.Container.proxyConverter,\r\n        '$data.Blob': function (b) { return b ? $data.Container.convertTo(b, $data.Blob) : b; },\r\n        '$data.Array': function (arr) { if (arr === undefined) { return new $data.Array(); } return arr; },\r\n        '$data.Object': $data.Container.proxyConverter,\r\n        \"$data.Guid\": function (g) { return g ? $data.parseGuid(g).toString() : g; },\r\n        '$data.GeographyPoint': function (g) { if (g) { return new $data.GeographyPoint(g); } return g; },\r\n        '$data.GeographyLineString': function (g) { if (g) { return new $data.GeographyLineString(g); } return g; },\r\n        '$data.GeographyPolygon': function (g) { if (g) { return new $data.GeographyPolygon(g); } return g; },\r\n        '$data.GeographyMultiPoint': function (g) { if (g) { return new $data.GeographyMultiPoint(g); } return g; },\r\n        '$data.GeographyMultiLineString': function (g) { if (g) { return new $data.GeographyMultiLineString(g); } return g; },\r\n        '$data.GeographyMultiPolygon': function (g) { if (g) { return new $data.GeographyMultiPolygon(g); } return g; },\r\n        '$data.GeographyCollection': function (g) { if (g) { return new $data.GeographyCollection(g); } return g; },\r\n        '$data.GeometryPoint': function (g) { if (g) { return new $data.GeometryPoint(g); } return g; },\r\n        '$data.GeometryLineString': function (g) { if (g) { return new $data.GeometryLineString(g); } return g; },\r\n        '$data.GeometryPolygon': function (g) { if (g) { return new $data.GeometryPolygon(g); } return g; },\r\n        '$data.GeometryMultiPoint': function (g) { if (g) { return new $data.GeometryMultiPoint(g); } return g; },\r\n        '$data.GeometryMultiLineString': function (g) { if (g) { return new $data.GeometryMultiLineString(g); } return g; },\r\n        '$data.GeometryMultiPolygon': function (g) { if (g) { return new $data.GeometryMultiPolygon(g); } return g; },\r\n        '$data.GeometryCollection': function (g) { if (g) { return new $data.GeometryCollection(g); } return g; }\r\n    },\r\n    toDb: {\r\n        '$data.Enum': $data.Container.proxyConverter,\r\n        '$data.Byte': $data.Container.proxyConverter,\r\n        '$data.SByte': $data.Container.proxyConverter,\r\n        '$data.Decimal': $data.Container.proxyConverter,\r\n        '$data.Float': $data.Container.proxyConverter,\r\n        '$data.Int16': $data.Container.proxyConverter,\r\n        '$data.Int64': $data.Container.proxyConverter,\r\n        '$data.Integer': $data.Container.proxyConverter,\r\n        '$data.Int32': $data.Container.proxyConverter,\r\n        '$data.Number': $data.Container.proxyConverter,\r\n        '$data.Date': $data.Container.proxyConverter,\r\n        '$data.DateTimeOffset': $data.Container.proxyConverter,\r\n        '$data.Duration': $data.Container.proxyConverter,\r\n        '$data.Day': $data.Container.proxyConverter,\r\n        '$data.Time': $data.Container.proxyConverter,\r\n        '$data.String': $data.Container.proxyConverter,\r\n        '$data.Boolean': $data.Container.proxyConverter,\r\n        '$data.Blob': function(b){ return b ? $data.Blob.toString(b) : b; },\r\n        '$data.Array': function (arr) { return arr ? JSON.parse(JSON.stringify(arr)) : arr; },\r\n        '$data.Object': $data.Container.proxyConverter,\r\n        \"$data.Guid\": function (g) { return g ? g.toString() : g; },\r\n        '$data.GeographyPoint': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeographyLineString': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeographyPolygon': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeographyMultiPoint': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeographyMultiLineString': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeographyMultiPolygon': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeographyCollection': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeometryPoint': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeometryLineString': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeometryPolygon': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeometryMultiPoint': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeometryMultiLineString': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeometryMultiPolygon': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeometryCollection': function (g) { if (g) { return g; } return g; }\r\n    }\r\n};\r\n","import $data, { $C, Guard, Container, Exception, MemberDefinition } from 'jaydata/core';\r\n\r\n$data.Class.define('$data.storageProviders.indexedDb.IndexedDBStorageProvider', $data.StorageProviderBase, null,\r\n{\r\n    constructor: function (cfg, ctxInstance) {\r\n        // mapping IndexedDB types to browser invariant name\r\n        this.indexedDB = $data.__global.indexedDB || $data.__global.webkitIndexedDB || $data.__global.mozIndexedDB || $data.__global.msIndexedDB;\r\n        this.IDBRequest = $data.__global.IDBRequest || $data.__global.webkitIDBRequest || $data.__global.mozIDBRequest || $data.__global.msIDBRequest;\r\n        this.IDBTransaction = $data.__global.IDBTransaction || $data.__global.webkitIDBTransaction || $data.__global.mozIDBTransaction || $data.__global.msIDBTransaction;\r\n        this.IDBTransactionType = { READ_ONLY: \"readonly\", READ_WRITE: \"readwrite\", VERSIONCHANGE: \"versionchange\" }\r\n        if (typeof this.IDBTransaction.READ_ONLY !== 'undefined' && typeof this.IDBTransaction.READ_WRITE !== 'undefined') {\r\n            this.IDBTransactionType.READ_ONLY = this.IDBTransaction.READ_ONLY\r\n            this.IDBTransactionType.READ_WRITE = this.IDBTransaction.READ_WRITE\r\n        }\r\n\r\n        this.IDBKeyRange = $data.__global.IDBKeyRange || $data.__global.webkitIDBKeyRange || $data.__global.mozIDBKeyRange || $data.__global.msIDBKeyRange;\r\n        this.IDBDatabaseException = $data.__global.IDBDatabaseException || $data.__global.webkitIDBDatabaseException || $data.__global.mozIDBDatabaseException || $data.__global.msIDBDatabaseException;\r\n        this.IDBOpenDBRequest = $data.__global.IDBOpenDBRequest || $data.__global.webkitIDBOpenDBRequest || $data.__global.mozIDBOpenDBRequest || $data.__global.msIDBOpenDBRequest;\r\n        this.newVersionAPI = !!($data.__global.IDBFactory && IDBFactory.prototype.deleteDatabase);\r\n        this.sequenceStore = '__jayData_sequence';\r\n        this.SqlCommands = [];\r\n        this.context = {};\r\n        this.providerConfiguration = $data.typeSystem.extend({\r\n            databaseName: $data.defaults.defaultDatabaseName,\r\n            version: 1,\r\n            dbCreation: $data.storageProviders.DbCreationType.DropTableIfChanged,\r\n            memoryOperations: true\r\n        }, cfg);\r\n        this._setupExtensionMethods();\r\n\r\n        if (ctxInstance)\r\n            this.originalContext = ctxInstance.getType();\r\n    },\r\n    supportedBinaryOperators: {\r\n        value: {\r\n            equal: { mapTo: ' == ', dataType: $data.Boolean },\r\n            notEqual: { mapTo: ' != ', dataType: $data.Boolean },\r\n            equalTyped: { mapTo: ' == ', dataType: $data.Boolean },\r\n            notEqualTyped: { mapTo: ' != ', dataType: $data.Boolean },\r\n            greaterThan: { mapTo: ' > ', dataType: $data.Boolean },\r\n            greaterThanOrEqual: { mapTo: ' >= ', dataType: $data.Boolean },\r\n\r\n            lessThan: { mapTo: ' < ', dataType: $data.Boolean },\r\n            lessThenOrEqual: { mapTo: ' <= ', dataType: $data.Boolean },\r\n            or: { mapTo: ' || ', dataType: $data.Boolean },\r\n            and: { mapTo: ' && ', dataType: $data.Boolean }\r\n            //'in': { mapTo: ' in ', dataType: $data.Boolean, resolvableType: [$data.Array, $data.Queryable] }\r\n        }\r\n    },\r\n    supportedSetOperations: {\r\n        value: {\r\n            length: {},\r\n            toArray: {},\r\n            forEach: {}\r\n        },\r\n        enumerable: true,\r\n        writable: true\r\n    },\r\n    supportedFieldOperations: {\r\n        value: {\r\n        },\r\n        enumerable: true,\r\n        writable: true\r\n    },\r\n    supportedUnaryOperators: {\r\n        value: {\r\n        },\r\n        enumerable: true,\r\n        writable: true\r\n    },\r\n    _setupExtensionMethods: function () {\r\n        /// <summary>\r\n        /// Sets the extension method 'setCallback' on IDBRequest, IDBOpenDBRequest, and IDBTransaction types\r\n        /// </summary>\r\n        var self = this;\r\n        var idbRequest = this.IDBRequest;\r\n        var idbTran = this.IDBTransaction;\r\n        var idbOpenDBRequest = this.IDBOpenDBRequest;\r\n        var setCallbacks = function (callbackSettings) {\r\n            /// <summary>\r\n            /// Sets the callbacks on the object.\r\n            /// </summary>\r\n            /// <param name=\"callbackSettings\">Named value pairs of the callbacks</param>\r\n            if (typeof callbackSettings !== 'object')\r\n                Guard.raise(new Exception('Invalid callbackSettings', null, callbackSettings));\r\n            for (var i in callbackSettings) {\r\n                if (typeof this[i] === 'undefined' || typeof callbackSettings[i] !== 'function')\r\n                    continue;\r\n                this[i] = callbackSettings[i];\r\n            }\r\n\r\n            //if (this.readyState == self.IDBRequest.DONE)\r\n            //    console.log('WARNING: request finished before setCallbacks. Do not use breakpoints between creating the request object and finishing the setting of callbacks');\r\n            return this;\r\n        };\r\n        if (idbRequest && typeof idbRequest.prototype.setCallbacks !== 'function')\r\n            idbRequest.prototype.setCallbacks = setCallbacks;\r\n        if (idbTran && typeof idbTran.prototype.setCallbacks !== 'function')\r\n            idbTran.prototype.setCallbacks = setCallbacks;\r\n        if (idbOpenDBRequest && typeof idbOpenDBRequest.prototype.setCallbacks !== 'function')\r\n            idbOpenDBRequest.prototype.setCallbacks = setCallbacks;\r\n    },\r\n    supportedDataTypes: {\r\n        value: [$data.Integer, $data.Number, $data.Date, $data.String, $data.Boolean, $data.Blob, $data.Array, $data.Object, $data.Guid, $data.GeographyPoint,\r\n            $data.GeographyLineString, $data.GeographyPolygon, $data.GeographyMultiPoint, $data.GeographyMultiLineString, $data.GeographyMultiPolygon, $data.GeographyCollection,\r\n            $data.GeometryPoint, $data.GeometryLineString, $data.GeometryPolygon, $data.GeometryMultiPoint, $data.GeometryMultiLineString, $data.GeometryMultiPolygon, $data.GeometryCollection,\r\n            $data.Byte, $data.SByte, $data.Decimal, $data.Float, $data.Int16, $data.Int32, $data.Int64, $data.Duration, $data.Day, $data.Time, $data.DateTimeOffset],\r\n        writable: false\r\n    },\r\n    fieldConverter: { value: $data.IndexedDBConverter },\r\n\r\n    supportedAutoincrementKeys: {\r\n        value: {\r\n            '$data.Integer': true,\r\n            '$data.Int32': true,\r\n            '$data.Guid': function () { return $data.createGuid(); }\r\n        }\r\n    },\r\n\r\n    _getObjectStoreDefinition: function (setDefinition) {\r\n        var contextStore = {\r\n            storeName: setDefinition.TableName\r\n        };\r\n        var keyFields = setDefinition.PhysicalType.memberDefinitions.getKeyProperties();\r\n\r\n        if (0 == keyFields.length) {\r\n            var error = new Error(\"Entity must have a key field: \" + contextStore.storeName);\r\n            error.name = \"KeyNotFoundError\";\r\n            throw error;\r\n        }\r\n        /*if (1 != keyFields.length) {\r\n            var error = new Error(\"Entity must have only one key field: \" + contextStore.storeName);\r\n            error.name = \"MultipleKeysNotSupportedError\";\r\n            throw error;\r\n        }*/\r\n        //var keyField = keyFields[0];\r\n        /*for (var i = 0; i < keyFields.length; i++) {\r\n\r\n            if (keyFields[i].computed === true &&\r\n                (\"$data.Integer\" !== Container.resolveName(keyFields[i].type))) {\r\n                var error = new Error(\"Computed key field must be of integer type: \" + contextStore.storeName);\r\n                error.name = \"ComputedKeyFieldError\";\r\n                throw error;\r\n            }\r\n            if (keyFields.length > 2 && keyFields[i].computed) {\r\n                var error = new Error(\"With multiple keys the computed field is not allowed: \" + contextStore.storeName);\r\n                error.name = \"MultipleComputedKeyFieldError\";\r\n                throw error;\r\n            }\r\n        }*/\r\n\r\n        if (keyFields.length > 2 && keyFields.some(function (memDef) { return memDef.computed; })) {\r\n            Guard.raise(\"With multiple keys the computed field is not allowed: \" + contextStore.storeName, \"MultipleComputedKeyFieldError\");\r\n        }\r\n\r\n        for (var i = 0; i < keyFields.length; i++) {\r\n            var typeName = Container.resolveName(keyFields[i].type);\r\n            if (keyFields[i].computed && !this.supportedAutoincrementKeys[typeName]) {\r\n                console.log(\"WARRNING! '\" + typeName + \"' not supported as computed Key!\");\r\n            }\r\n        }\r\n\r\n        contextStore.keyFields = keyFields;\r\n        return contextStore;\r\n    },\r\n\r\n    _getObjectStoreDefinitions: function () {\r\n        var objectStoreDefinitions = [];\r\n        var self = this;\r\n        self.context._storageModel.forEach(function (memDef) {\r\n            var objectStoreDefinition = self._getObjectStoreDefinition(memDef);\r\n            objectStoreDefinitions.push(objectStoreDefinition);\r\n        });\r\n        return objectStoreDefinitions;\r\n    },\r\n\r\n    _oldCreateDB: function (setVersionTran, definitions, onready) {\r\n        var self = this;\r\n        setVersionTran.db.onversionchange = function (event) {\r\n            return event.target.close();\r\n        };\r\n\r\n        self._createDB(setVersionTran.db, definitions);\r\n        setVersionTran.oncomplete = onready;\r\n    },\r\n    _createDB: function (db, definitions) {\r\n        for (var i = 0; i < definitions.length; i++) {\r\n            if (definitions[i].dropIfExists && db.objectStoreNames.contains(definitions[i].storeName)) {\r\n                db.deleteObjectStore(definitions[i].storeName);\r\n            }\r\n        }\r\n\r\n        for (var i = 0; i < definitions.length; i++) {\r\n            var storeDef = definitions[i];\r\n\r\n            if (!db.objectStoreNames.contains(storeDef.storeName)) {\r\n                var settings = {};\r\n                if (storeDef.keyFields.length == 1) {\r\n                    settings = {\r\n                        keyPath: storeDef.keyFields[0].name\r\n                        //autoIncrement: storeDef.keyFields[0].computed\r\n                    };\r\n                    var typeName = Container.resolveName(storeDef.keyFields[0].type);\r\n                    settings.autoIncrement = this.supportedAutoincrementKeys[typeName] ? true : false;\r\n                } else {\r\n                    settings.key = [];\r\n                    for (var i = 0; i < storeDef.keyFields.length; i++) {\r\n                        settings.key.push(storeDef.keyFields[i].name);\r\n                    }\r\n                }\r\n                db.createObjectStore(storeDef.storeName, settings);\r\n            }\r\n        }\r\n    },\r\n    _hasDbChanges: function (db, definitions, dropTabes) {\r\n        var isOriginal = true;\r\n        for (var i = 0; i < definitions.length; i++) {\r\n            isOriginal = isOriginal && db.objectStoreNames.contains(definitions[i].storeName);\r\n\r\n            if (dropTabes) {\r\n                definitions[i].dropIfExists = true;\r\n                isOriginal = false;\r\n            }\r\n        }\r\n\r\n        return !isOriginal;\r\n    },\r\n    onupgradeneeded: function (objectStoreDefinitions) {\r\n        var self = this;\r\n        return function (e) {\r\n            var db = e.target.result;\r\n            db.onversionchange = function (event) {\r\n                return event.target.close();\r\n            };\r\n            var hasTableChanges = self._hasDbChanges(db, objectStoreDefinitions, self.providerConfiguration.dbCreation == $data.storageProviders.DbCreationType.DropAllExistingTables);\r\n            if (hasTableChanges)\r\n                self._createDB(db, objectStoreDefinitions);\r\n        }\r\n    },\r\n\r\n    initializeStore: function (callBack) {\r\n        callBack = $data.PromiseHandlerBase.createCallbackSettings(callBack);\r\n        var self = this;\r\n\r\n        this.initializeMemoryStore({\r\n            success: function () {\r\n                var objectStoreDefinitions;\r\n                try {\r\n                    objectStoreDefinitions = self._getObjectStoreDefinitions();\r\n                } catch (e) {\r\n                    console.log(objectStoreDefinitions);\r\n                    callBack.error(e);\r\n                    return;\r\n                }\r\n                self.indexedDB.open(self.providerConfiguration.databaseName).setCallbacks({\r\n                    onsuccess: function (e) {\r\n                        var db = e.target.result;\r\n                        db.onversionchange = function (event) {\r\n                            return event.target.close();\r\n                        };\r\n\r\n                        var hasTableChanges = self._hasDbChanges(db, objectStoreDefinitions, self.providerConfiguration.dbCreation == $data.storageProviders.DbCreationType.DropAllExistingTables);\r\n                        //oldAPI\r\n                        if (db.setVersion) {\r\n                            if (db.version === \"\" || hasTableChanges) {\r\n                                db.setVersion((parseInt(db.version) || 0) + 1).setCallbacks({\r\n                                    onsuccess: function (e) {\r\n                                        var db = e.target.result\r\n                                        self._oldCreateDB(db /*setVerTran*/, objectStoreDefinitions, function (e) {\r\n                                            self.db = e.target.db;\r\n                                            callBack.success(self.context);\r\n                                        });\r\n                                    },\r\n                                    onerror: function () {\r\n                                        var v = arguments;\r\n                                    },\r\n                                    onblocked: function () {\r\n                                        var v = arguments;\r\n                                    }\r\n                                });\r\n                                return;\r\n                            };\r\n                        } else if (hasTableChanges) {\r\n                            //newVersionAPI\r\n                            db.close();\r\n                            var version = parseInt(db.version) + 1;\r\n                            self.indexedDB.open(self.providerConfiguration.databaseName, version).setCallbacks({\r\n                                onsuccess: function (e) {\r\n                                    self.db = e.target.result;\r\n                                    callBack.success(self.context);\r\n                                },\r\n                                onupgradeneeded: self.onupgradeneeded(objectStoreDefinitions),\r\n                                onerror: callBack.error,\r\n                                onabort: callBack.error,\r\n                                onblocked: callBack.error\r\n                            });\r\n                            return;\r\n                        }\r\n\r\n                        self.db = db;\r\n                        callBack.success(self.context);\r\n                    },\r\n                    //newVersionAPI\r\n                    onupgradeneeded: self.onupgradeneeded(objectStoreDefinitions),\r\n                    onerror: callBack.error,\r\n                    onabort: callBack.error,\r\n                    onblocked: callBack.error\r\n                });\r\n            },\r\n            error: callBack.error\r\n        });\r\n    },\r\n    initializeMemoryStore: function (callBack) {\r\n        callBack = $data.PromiseHandlerBase.createCallbackSettings(callBack);\r\n        var self = this;\r\n\r\n        if (self.originalContext && self.providerConfiguration.memoryOperations) {\r\n            self.operationProvider = new self.originalContext({ name: 'InMemory' });\r\n            self.operationProvider.onReady({\r\n                success: function () {\r\n                    self.supportedBinaryOperators = self.operationProvider.storageProvider.supportedBinaryOperators;\r\n                    self.supportedSetOperations = self.operationProvider.storageProvider.supportedSetOperations;\r\n                    self.supportedFieldOperations = self.operationProvider.storageProvider.supportedFieldOperations;\r\n                    self.supportedUnaryOperators = self.operationProvider.storageProvider.supportedUnaryOperators;\r\n                    callBack.success();\r\n                },\r\n                error: callBack.error\r\n            });\r\n        } else {\r\n            callBack.success();\r\n        }\r\n    },\r\n\r\n    _initializeStore: function (callBack) {\r\n        callBack = $data.PromiseHandlerBase.createCallbackSettings(callBack);\r\n        var self = this;\r\n\r\n\r\n        var initDb = function (db) {\r\n            db.onversionchange = function (event) {\r\n                var ret = event.target.close();\r\n                return ret;\r\n            };\r\n            var newSequences = [];\r\n            self.context._storageModel.forEach(function (memDef) {\r\n                function createStore() {\r\n                    /// <summary>\r\n                    /// Creates a store for 'memDef'\r\n                    /// </summary>\r\n                    var osParam = {};\r\n                    var keySettings = self._getKeySettings(memDef);\r\n                    if (self.newVersionAPI) {\r\n                        if (keySettings.autoIncrement)\r\n                            newSequences.push(memDef.TableName);\r\n                    } else {\r\n                        osParam.autoIncrement = keySettings.autoIncrement;\r\n                    }\r\n                    if (keySettings.keyPath !== undefined)\r\n                        osParam.keyPath = keySettings.keyPath;\r\n                    db.createObjectStore(memDef.TableName, osParam);\r\n                }\r\n                if (db.objectStoreNames.contains(memDef.TableName)) {\r\n                    // ObjectStore already present.\r\n                    if (self.providerConfiguration.dbCreation === $data.storageProviders.DbCreationType.DropAllExistingTables) {\r\n                        // Force drop and recreate object store\r\n                        db.deleteObjectStore(memDef.TableName);\r\n                        createStore();\r\n                    }\r\n                } else {\r\n                    // Store does not exists yet, we need to create it\r\n                    createStore();\r\n                }\r\n            });\r\n            if (newSequences.length > 0 && !db.objectStoreNames.contains(self.sequenceStore)) {\r\n                // Sequence store does not exists yet, we create it\r\n                db.createObjectStore(self.sequenceStore, { keyPath: 'store' });\r\n                newSequences = [];\r\n            }\r\n            return newSequences;\r\n        }\r\n        var newSequences = null;\r\n        // Creating openCallbacks settings for both type of db.open() method\r\n        var openCallbacks = {\r\n            onupgradeneeded: function (event) {\r\n                newSequences = initDb(event.target.result);\r\n            },\r\n            onerror: callBack.error,\r\n            onblocked: callBack.error,\r\n            onsuccess: function (event) {\r\n                self.db = event.target.result;\r\n                self.db.onversionchange = function (event) {\r\n                    event.target.close();\r\n                }\r\n                if (self.newVersionAPI) {\r\n                    if (newSequences && newSequences.length > 0) {\r\n                        var store = self.db.transaction([self.sequenceStore], self.IDBTransactionType.READ_WRITE).setCallbacks({\r\n                            onerror: callBack.error,\r\n                            oncomplete: function () {\r\n                                callBack.success(self.context);\r\n                            }\r\n                        }).objectStore(self.sequenceStore);\r\n                        switch (self.providerConfiguration.dbCreation) {\r\n                            case $data.storageProviders.DbCreationType.DropAllExistingTables:\r\n                            case $data.storageProviders.DbCreationType.DropTableIfChanged:\r\n                                // Clearing all data\r\n                                store.clear();\r\n                                break;\r\n                            default:\r\n                                // Removing data for newly created stores, if they previously existed\r\n                                newSequences.forEach(function (item) {\r\n                                    store['delete'](item);\r\n                                });\r\n                                break;\r\n                        }\r\n                    }\r\n                    callBack.success(self.context);\r\n                }\r\n                else {\r\n                    // Calling setVersion on webkit\r\n                    var versionRequest = self.db.setVersion(self.providerConfiguration.version.toString()).setCallbacks({\r\n                        onerror: callBack.error,\r\n                        onblocked: callBack.error,\r\n                        onsuccess: function (event) {\r\n                            initDb(self.db);\r\n                            versionRequest.result.oncomplete = function (evt) {\r\n                                callBack.success(self.context);\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        };\r\n        // For Firefox we need to pass the version here\r\n        if (self.newVersionAPI)\r\n            self.indexedDB.open(self.providerConfiguration.databaseName, parseInt(self.providerConfiguration.version, 10)).setCallbacks(openCallbacks);\r\n        else\r\n            self.indexedDB.open(self.providerConfiguration.databaseName).setCallbacks(openCallbacks);\r\n    },\r\n\r\n    executeQuery: function (query, callBack) {\r\n        callBack = $data.PromiseHandlerBase.createCallbackSettings(callBack);\r\n        var self = this;\r\n\r\n        //var compiledQuery = self._compile(query);\r\n\r\n        // Creating read only transaction for query. Results are passed in transaction's oncomplete event\r\n        var entitySet = query.context.getEntitySetFromElementType(query.defaultType);\r\n        var store = self.db.transaction([entitySet.tableName], self.IDBTransactionType.READ_ONLY).setCallbacks({\r\n            onerror: callBack.error,\r\n            onabort: callBack.error,\r\n            oncomplete: function (event) {\r\n                if (self.operationProvider) {\r\n                    self.operationProvider.storageProvider.dataSource[entitySet.tableName] = query.rawDataList;\r\n                    self.operationProvider.storageProvider.executeQuery(query, {\r\n                        success: function (query) {\r\n                            if (query.expression.nodeType === $data.Expressions.ExpressionType.Count) {\r\n                                query.rawDataList[0] = { cnt: query.rawDataList[0] };\r\n                            }\r\n                            callBack.success(query);\r\n                        },\r\n                        error: callBack.error\r\n                    });\r\n                } else {\r\n                    callBack.success(query);\r\n                }\r\n            }\r\n        }).objectStore(entitySet.tableName);\r\n        var modelBinderCompiler = Container.createModelBinderConfigCompiler(query, []);\r\n        modelBinderCompiler.Visit(query.expression);\r\n\r\n        if (self.operationProvider) {\r\n            store.openCursor().onsuccess = function (event) {\r\n                // We currently support only toArray() so let's just dump all data\r\n                var cursor = event.target.result;\r\n                if (cursor) {\r\n                    var value = cursor.value;\r\n                    query.rawDataList.push(cursor.value);\r\n                    cursor['continue']();\r\n                }\r\n            };\r\n        } else {\r\n            switch (query.expression.nodeType) {\r\n                case $data.Expressions.ExpressionType.Count:\r\n                    store.count().onsuccess = function (event) {\r\n                        var count = event.target.result;\r\n                        query.rawDataList.push({ cnt: count });\r\n                    }\r\n                    break;\r\n                default:\r\n                    store.openCursor().onsuccess = function (event) {\r\n                        // We currently support only toArray() so let's just dump all data\r\n                        var cursor = event.target.result;\r\n                        if (cursor) {\r\n                            var value = cursor.value;\r\n                            query.rawDataList.push(cursor.value);\r\n                            cursor['continue']();\r\n                        }\r\n                    };\r\n                    break;\r\n            }\r\n        };\r\n    },\r\n    _getKeySettings: function (memDef) {\r\n        /// <summary>\r\n        /// Gets key settings for item type's member definition\r\n        /// </summary>\r\n        /// <param name=\"memDef\">memDef of item</param>\r\n        /// <returns>KeySettings object</returns>\r\n        var self = this;\r\n        var settings = { autoIncrement: false };\r\n        var keys = [];\r\n        memDef.PhysicalType.memberDefinitions\r\n            .getPublicMappedProperties().forEach(function (item) {\r\n                if (item.key) {\r\n                    // We found a key\r\n                    keys.push(item.name);\r\n                }\r\n                if (item.computed) {\r\n                    // AutoIncrement field, must be key\r\n                    if (!item.key)\r\n                        Guard.raise(new Exception('Only key field can be a computed field!'));\r\n\r\n                    var typeName = Container.resolveName(item.type);\r\n                    if (self.supportedAutoincrementKeys[typeName] === true) {\r\n                        settings.autoIncrement = true;\r\n                    }\r\n                }\r\n            });\r\n        if (keys.length > 1) {\r\n            if (settings.autoIncrement)\r\n                Guard.raise(new Exception('Auto increment is only valid for a single key!'));\r\n            // Setting key fields (composite key)\r\n            settings.keys = keys;\r\n        } else if (keys.length == 1) {\r\n            // Simple key\r\n            settings.keyPath = keys[0];\r\n        } else {\r\n            Guard.raise(new Exception('No valid key found!'));\r\n        }\r\n        return settings;\r\n    },\r\n    saveChanges: function (callBack, changedItems) {\r\n        var self = this;\r\n        // Building independent blocks and processing them sequentially\r\n        var independentBlocks = self.buildIndependentBlocks(changedItems);\r\n        function saveNextIndependentBlock() {\r\n            /// <summary>\r\n            /// Saves the next independent block\r\n            /// </summary>\r\n            if (independentBlocks.length === 0) {\r\n                // No more blocks left, calling success callback\r\n                callBack.success();\r\n            } else {\r\n                // 'Popping' next block\r\n                var currentBlock = independentBlocks.shift();\r\n                // Collecting stores of items for transaction initialize\r\n                var storesObj = {};\r\n                // Generating physicalData\r\n                var convertedItems = currentBlock.map(function (item) {\r\n                    storesObj[item.entitySet.tableName] = true;\r\n                    item.physicalData = {};\r\n                    item.entitySet.elementType.memberDefinitions\r\n                        .getPublicMappedProperties().forEach(function (memDef) {\r\n                            var typeName = Container.resolveName(memDef.type);\r\n                            if (memDef.key && memDef.computed && item.data[memDef.name] == undefined) {\r\n                                if (typeof self.supportedAutoincrementKeys[typeName] === 'function') {\r\n                                    var keyValue = self.supportedAutoincrementKeys[typeName]();\r\n                                    item.data[memDef.name] = self.fieldConverter.toDb[typeName](keyValue);\r\n                                } else {\r\n                                    // Autogenerated fields for new items should not be present in the physicalData\r\n                                    return;\r\n                                }\r\n                            }\r\n                            if (!memDef.inverseProperty && typeof memDef.concurrencyMode === 'undefined' && (memDef.key === true || item.data.entityState === $data.EntityState.Added || (item.data.changedProperties && item.data.changedProperties.some(function (def) { return def.name === memDef.name; })))) {\r\n                                if (self.fieldConverter.toDb[typeName]) {\r\n                                    item.physicalData[memDef.name] = self.fieldConverter.toDb[typeName](item.data[memDef.name]);\r\n                                } else {\r\n                                    var value = item.data[memDef.name];\r\n                                    if (value !== undefined) {\r\n                                        value = JSON.parse(JSON.stringify(value));\r\n                                    }\r\n                                    item.physicalData[memDef.name] = value;\r\n                                }\r\n                            }\r\n                        });\r\n                    return item;\r\n                });\r\n                var stores = [];\r\n                for (var i in storesObj) {\r\n                    stores.push(i);\r\n                }\r\n                var tran = self.db.transaction(stores, self.IDBTransactionType.READ_WRITE).setCallbacks({\r\n                    onerror: function (event) {\r\n                        // Only call the error callback when it's not because of an abort\r\n                        // aborted cases should call the error callback there\r\n                        if (!event.target || !self.IDBDatabaseException || (event.target && self.IDBDatabaseException && event.target.errorCode !== self.IDBDatabaseException.ABORT_ERR))\r\n                            callBack.error(event);\r\n                    },\r\n                    oncomplete: function (event) {\r\n                        // Moving to next block\r\n                        saveNextIndependentBlock();\r\n                    }\r\n                });\r\n                function KeySettingsCache() {\r\n                    /// <summary>\r\n                    /// Simple cache for key settings of types\r\n                    /// </summary>\r\n                    var cache = {};\r\n                    this.getSettingsForItem = function (item) {\r\n                        var typeName = item.data.getType().fullName;\r\n                        if (!cache.hasOwnProperty(typeName)) {\r\n                            cache[typeName] = self._getKeySettings(self.context._storageModel.getStorageModel(item.data.getType()));\r\n                        }\r\n                        return cache[typeName]\r\n                    }\r\n                }\r\n                var ksCache = new KeySettingsCache();\r\n                convertedItems.forEach(function (item) {\r\n                    // Getting store and keysettings for the current item\r\n                    var store = tran.objectStore(item.entitySet.tableName);\r\n                    var keySettings = ksCache.getSettingsForItem(item);\r\n                    // Contains the keys that should be passed for create, update and delete (composite keys)\r\n                    var itemKeys = keySettings.keys && keySettings.keys.map(function (key) { return item.physicalData[key]; }) || null;\r\n                    try {\r\n                        var cursorAction = function (action) {\r\n                            /// <summary>\r\n                            /// Find the current item in the store, and calls the action on it. Error raised when item was not found\r\n                            /// </summary>\r\n                            /// <param name=\"action\">Action to call on the item</param>\r\n                            var key = keySettings.keyPath ? item.physicalData[keySettings.keyPath] : itemKeys;\r\n                            var data = item.physicalData;\r\n                            store.openCursor(self.IDBKeyRange.only(key))\r\n                                .onsuccess = function (event) {\r\n                                    try {\r\n                                        var cursor = event.target.result;\r\n                                        if (cursor)\r\n                                            action(cursor, key, data);\r\n                                        else\r\n                                            Guard.raise(new Exception('Object not found', null, item));\r\n                                    } catch (ex) {\r\n                                        tran.abort();\r\n                                        callBack.error(ex);\r\n                                    }\r\n                                }\r\n                        };\r\n                        switch (item.data.entityState) {\r\n                            case $data.EntityState.Added:\r\n                                if (!keySettings.keyPath) {\r\n                                    // Item needs explicit keys\r\n                                    store.add(item.physicalData, itemKeys);\r\n                                }\r\n                                else {\r\n                                    store.add(item.physicalData)\r\n                                        .onsuccess = function (event) {\r\n                                            // Saves the generated key back to the entity\r\n                                            item.data[keySettings.keyPath] = event.target.result;\r\n                                        };\r\n                                }\r\n                                break;\r\n                            case $data.EntityState.Deleted:\r\n                                // Deletes the item\r\n                                cursorAction(function (cursor) {\r\n                                    cursor['delete']();\r\n                                });\r\n                                break;\r\n                            case $data.EntityState.Modified:\r\n                                // Updates the item\r\n                                cursorAction(function (cursor, key, data) {\r\n                                    cursor.update($data.typeSystem.extend(cursor.value, data));\r\n                                });\r\n                                break;\r\n                            case $data.EntityState.Unchanged:\r\n                                break;\r\n                            default:\r\n                                Guard.raise(new Exception('Not supported entity state', null, item));\r\n                        }\r\n                    } catch (ex) {\r\n                        // Abort on exceptions\r\n                        tran.abort();\r\n                        callBack.error(ex);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        saveNextIndependentBlock();\r\n    },\r\n    _compile: function (query) {\r\n        var sqlText = Container.createIndexedDBCompiler().compile(query);\r\n        return sqlText;\r\n    }\r\n}, {\r\n    isSupported: {\r\n        get: function () {\r\n            return $data.__global.indexedDB || $data.__global.webkitIndexedDB || $data.__global.mozIndexedDB || $data.__global.msIndexedDB ? true : false;\r\n        },\r\n        set: function () { }\r\n    }\r\n});\r\n\r\nif ($data.storageProviders.indexedDb.IndexedDBStorageProvider.isSupported)\r\n    $data.StorageProviderBase.registerProvider('indexedDb', $data.storageProviders.indexedDb.IndexedDBStorageProvider);\r\n","import $data from 'jaydata/core';\r\n\r\nimport IndexedDBConverter from './IndexedDBConverter.js';\r\nimport IndexedDBStorageProvider from './IndexedDBStorageProvider.js';\r\n\r\nexport default $data;\r\n"],"sourceRoot":"/source/"}